<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<meta content="width=device-width,initial-scale=1" name="viewport"/>
<title>Slot Machine UI â€” 3D Cylinder (User Choice)</title>
<style>
    :root { --accent:#ffcc33; --bg:#0a0a0a; --panel:#111; }
    html, body { height:100%; cursor: none; }
    body { margin:0; background:var(--bg); color:#eaeaea; font-family:ui-sans-serif, system-ui, -apple-system; }
    header { text-align:center; padding:24px 12px; font-weight:400; letter-spacing:.5px; 
             font-family: "ironmonger-inlaid", sans-serif; font-style: normal; }
    .status { text-align:center; padding:8px; min-height:24px; opacity:.9; color: #ffcc33; }
    .wrap { display:grid; grid-template-columns:1fr 1fr 1fr; gap:24px; height:calc(100vh - 190px); padding:24px; box-sizing:border-box; }
    .reel { position:relative; border:4px solid #1a1a1a; border-radius:24px; background:var(--panel); box-shadow:0 0 40px #000 inset; overflow:hidden; }
    .scene { width:100%; height:100%; perspective: 1000px; perspective-origin: 50% 50%; position:relative; }
    .cyl { width:100%; height:100%; position:absolute; inset:0; transform-style: preserve-3d; will-change: transform; }
    .panel { position:absolute; top:50%; left:50%; width:86%; height:92px; margin-left:-43%; margin-top:-46px;
             display:flex; align-items:center; justify-content:center; font-size:clamp(10px,2vw,48px); text-shadow:0 2px 2px rgba(0,0,0,.3);
             color:#eaeaea; backface-visibility: hidden; user-select:none; }
    .reel::after { content:""; position:absolute; left:0; right:0; top:50%; height:0; border-top:2px solid var(--accent);
                   opacity:.5; transform: translateY(-1px); pointer-events:none; z-index:5; }
    .fadeMask { position:absolute; inset:0; pointer-events:none; z-index:4;
                background: linear-gradient(to bottom, rgba(10,10,10,0.95), rgba(10,10,10,0.0) 20%, rgba(10,10,10,0.0) 80%, rgba(10,10,10,0.95)); }
    .stopBadge { position:absolute; bottom:16px; right:16px; background:#1c1; color:#012; font-weight:800;
                 padding:8px 12px; border-radius:12px; display:none; z-index:6; }
    footer.controls { display:flex; gap:16px; justify-content:center; padding:16px; flex-wrap:wrap; }
    button { font-size:22px; padding:16px 24px; border-radius:12px; border:none; background:#1a1a1a; color:#fff; cursor:pointer; }
    button.primary { background:var(--accent); color:#001018; font-weight:800; }
    button:disabled { opacity:.5; cursor:not-allowed; }
  
/* === POLISH PACK v1 === */
/* Theme */
:root { --accent: #ffcc33; }
body { background: radial-gradient(circle at center, #111 0%, #000 100%); }
/* Reel chrome/glass */
.reel {
  border: 2px solid #ffcc33;
  box-shadow: inset 0 2px 6px rgba(255,204,51,0.2), inset 0 -3px 10px rgba(0,0,0,0.6), 0 10px 24px rgba(255,204,51,0.15);
  background: linear-gradient(to bottom,#1a1a1a,#0f0f0f);
  border-radius: 16px;
  overflow: hidden;
}
/* Center payline glow */
.fadeMask::after {
  content:"";
  position:absolute; left:0; right:0; top:50%;
  height:2px; transform:translateY(-1px);
  background: linear-gradient(90deg, transparent, var(--accent), transparent);
  filter: drop-shadow(0 0 6px var(--accent));
  opacity:.6; animation: pulse 2.2s ease-in-out infinite;
}
@keyframes pulse { 0%,100%{opacity:.25} 50%{opacity:.9} }
/* Typography for symbols */
.cyl div {
  font-family: "ironmonger-inlaid", freehouse, serif;
  font-weight: 400;
  font-style: normal;
  text-transform: uppercase;
  letter-spacing: 1px;
  line-height: 1.25;
}
/* Stop badges pop */
.stopBadge {
  transform: scale(0.8);
  opacity: 0;
  transition: transform .18s ease, opacity .18s ease;
}
.stopBadge.show { display:block !important; transform: scale(1); opacity: 1; }
/* Lever */
.lever {
  display:inline-block; margin-left:12px;
  width:60px; height:120px; position:relative; vertical-align:middle;
  background: linear-gradient(#5a5a5a,#2a2a2a);
  border:3px solid #888; border-radius:30px;
  box-shadow: 0 6px 18px rgba(0,0,0,.45);
  cursor:pointer;
}
.lever::after {
  content:""; position:absolute; top:-18px; left:50%; transform:translateX(-50%);
  width:20px; height:20px; border-radius:50%;
  background: var(--accent); box-shadow:0 0 10px var(--accent), inset 0 0 6px rgba(255,255,255,.6);
}
@media (prefers-reduced-motion: reduce){
  .fadeMask::after { animation: none; opacity: .35; }
}
/* === END POLISH PACK === */

/* === LOADING OVERLAY === */
.loading-overlay {
  position: fixed;
  inset: 0;
  display: none;
  align-items: center;
  justify-content: center;
  /* Removed heavy blur for better performance on Raspberry Pi. */
  background: rgba(0,0,0,0.55);
  /* No backdrop-filter to avoid freezing during overlay display. */
  z-index: 999;
}
.loading-overlay.show { display: flex; }
.loading-card {
  min-width: 320px;
  max-width: 520px;
  padding: 24px;
  border-radius: 16px;
  background: linear-gradient(180deg, #0f1216, #0b0d10);
  /* Simplified shadow to reduce heavy compositing load on low-power devices */
  box-shadow: 0 10px 24px rgba(0,0,0,0.4);
  border: 1px solid rgba(255,255,255,0.06);
  text-align: center;
}
.spinner {
  width: 52px; height: 52px;
  border: 5px solid rgba(255,255,255,0.15);
  border-top-color: var(--accent);
  border-radius: 50%;
  margin: 0 auto 16px auto;
  animation: spin 1s linear infinite;
}
@keyframes spin { to { transform: rotate(360deg); } }
.progressbar {
  height: 8px;
  border-radius: 999px;
  background: rgba(255,255,255,0.08);
  overflow: hidden;
  margin-top: 10px;
}
.progressbar > div {
  width: 40%;
  height: 100%;
  border-radius: 999px;
  background: linear-gradient(90deg, rgba(255,255,255,0.0), var(--accent), rgba(255,255,255,0.0));
  /* Simplified animation timing to lighten CPU usage */
  animation: slide 1.5s ease-in-out infinite;
}
@keyframes slide {
  0%   { margin-left: -40%; width: 20%; }
  50%  { margin-left: 20%;  width: 60%; }
  100% { margin-left: 100%; width: 20%; }
}
.loading-title { font-weight: 800; font-size: 22px; margin-bottom: 4px; color: #ffffcc; }
.loading-sub { opacity: .85; font-size: 14px; color: #ffffcc; }
.hint { font-size: 12px; opacity: .6; margin-top: 8px; }
</style>
<link rel="stylesheet" href="https://use.typekit.net/ihx7ouu.css">
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500&display=swap" rel="stylesheet"/></head>
<body>
<header>
  <div class="status" id="status">Stop each reel with the symbol you want on the payline.</div>
</header>

<!-- SLOT UI -->
<div class="wrap">
  <div class="reel"><div class="scene"><div class="cyl" id="cyl0"></div></div><div class="fadeMask"></div><div class="stopBadge" id="sb0">Stopped</div></div>
  <div class="reel"><div class="scene"><div class="cyl" id="cyl1"></div></div><div class="fadeMask"></div><div class="stopBadge" id="sb1">Stopped</div></div>
  <div class="reel"><div class="scene"><div class="cyl" id="cyl2"></div></div><div class="fadeMask"></div><div class="stopBadge" id="sb2">Stopped</div></div>
</div>

<footer class="controls">
  <button onclick="stopReel(0)">Stop A</button>
  <button onclick="stopReel(1)">Stop B</button>
  <button onclick="stopReel(2)">Stop C</button>
  <button class="primary" id="resetBtn" onclick="resetAll()">Reset</button>
  <button class="primary" onclick="window.location.href='/gallery.html'">ðŸ“¸ View Gallery</button>
</footer>

<!-- LOADING OVERLAY -->
<div id="loadingOverlay" class="loading-overlay" aria-hidden="true">
  <div class="loading-card" role="dialog" aria-live="polite">
    <div class="spinner" aria-hidden="true"></div>
    <div class="loading-title" id="loadingTitle">Workingâ€¦</div>
    <div class="loading-sub" id="loadingSub">Composing prompt & generating your brainrot.</div>
    <div class="progressbar"><div></div></div>
    <div class="hint">This might take a moment...</div>
  </div>
</div>

<script>
const ROW_H = 92;
const ROT_SPEEDS = [0.025, 0.025, 0.025]; // deg/ms
let ws;
let reels = [[],[],[]];
let spinning = [true,true,true];
let rotX = [0,0,0];
let lastTS = performance.now();
let cylEls = [];
let badgeEls = [];
// Track when the server has declared that all reels are stopped. We defer
// showing the loading overlay until the final reel's animation and badge
// have painted on screen.
let allStoppedPending = false;
// Helper to show the overlay only after the UI has finished snapping all
// reels and displaying their badges. If all three reels are stopped and
// the server has sent an `all_stopped` event, this will send a handshake
// to trigger generation and show the loading overlay.
function maybeShowOverlay(){
  console.log("[Handshake] Checking:", {allStoppedPending, spinning, wsReady: ws && ws.readyState === 1});
  if (allStoppedPending && spinning.every(v => !v)){
    // All reels are visually stopped, send handshake to backend
    if (ws && ws.readyState === 1) {
      console.log("[Handshake] Sending start_generation to backend");
      ws.send(JSON.stringify({type: "start_generation"}));
      allStoppedPending = false;
    } else {
      console.log("[Handshake] WebSocket not ready");
    }
  }
}
// Loading overlay helpers
function showOverlay(title="Brewing your brainrotâ€¦", sub="Composing prompt & generating image.") {
  const o = document.getElementById('loadingOverlay');
  document.getElementById('loadingTitle').textContent = title;
  document.getElementById('loadingSub').textContent = sub;
  o.classList.add('show');
  o.setAttribute('aria-hidden', 'false');
}

function hideOverlay(){
  const o = document.getElementById('loadingOverlay');
  o.classList.remove('show');
  o.setAttribute('aria-hidden', 'true');
}

function connect(){
  ws = new WebSocket(`ws://${location.host}/ws`);
  ws.onmessage = (ev)=>{
    const msg = JSON.parse(ev.data);
    if (msg.type === 'init') initUI(msg.reels);
    // A physical switch state change from the server; capture the visible symbol and send
    // a stop_reel command on state change. This ensures that the spinning
    // state and UI are updated consistently when using GPIO switches.
    if (msg.type === 'gpio_press') {
      // Handle both press and release events - any state change stops the reel
      if (spinning[msg.reel] && ws && ws.readyState === 1) {
        spinning[msg.reel] = false;
        const symbol = currentSymbol(msg.reel);
        ws.send(JSON.stringify({ type: "stop_reel", reel: msg.reel, symbol }));
        const action = msg.action || 'activated';
        setStatus(`Locked ${"ABC"[msg.reel]} (GPIO ${action}): ${symbol}.`);
        if (spinning.every(v => !v)) {
          document.querySelectorAll('button:not(.primary)')
            .forEach(b => b.disabled = true);
        }
      }
    }

    if (msg.type === 'reel_stopped') onReelStopped(msg.reel, msg.symbol);
    if (msg.type === 'all_stopped') {
      // Set status and flag that backend is ready
      allStoppedPending = true;
      setStatus("All reels stopped. Ready to generateâ€¦");
      // Check immediately if frontend is also ready (all animations done)
      maybeShowOverlay();
      return;
    }
    if (msg.type === 'generation_started') {
      setStatus("Generating your brainrotâ€¦");
      showOverlay("Brewing your brainrotâ€¦","Composing prompt & generating image.");
    }
    if (msg.type === 'image_ready') {
      hideOverlay();
      window.location.href = "/gallery.html?url=" + encodeURIComponent(msg.url)
                           + "&name=" + encodeURIComponent(msg.italian_name)
                           + "&prompt=" + encodeURIComponent(msg.prompt);
    }
    if (msg.type === 'error') {
      hideOverlay();
      setStatus("âš ï¸ " + msg.message + " Click Reset to try again.");
      // Auto-enable reset button on error
      document.querySelectorAll('button').forEach(b => b.disabled = false);
    }
  };
  ws.onclose = ()=>{
    setStatus("Disconnected. Reconnectingâ€¦");
    hideOverlay();
    setTimeout(connect, 800);
  };
}
function setStatus(s){ document.getElementById('status').textContent = s; }
function buildCylinder(i){
  const cyl = document.getElementById(`cyl${i}`);
  cyl.innerHTML = "";
  const items = reels[i]; const n = items.length; const step = 360 / n; const R = (ROW_H * n) / (2 * Math.PI);
  items.forEach((txt, idx)=>{
    const panel = document.createElement('div');
    panel.className = 'panel'; panel.textContent = txt;
    panel.style.transform = `rotateX(${idx * step}deg) translateZ(${R}px)`;
    cyl.appendChild(panel);
  });
  cyl.dataset.step = step.toString();
  rotX[i] = 0; cyl.style.transform = `rotateX(${rotX[i]}deg)`;
}
function initUI(reelData){
  reels = [reelData[0], reelData[1], reelData[2]];
  cylEls = [document.getElementById('cyl0'), document.getElementById('cyl1'), document.getElementById('cyl2')];
  badgeEls = [document.getElementById('sb0'), document.getElementById('sb1'), document.getElementById('sb2')];
  for (let i=0;i<3;i++) buildCylinder(i);
  lastTS = performance.now(); requestAnimationFrame(tick);
}
function tick(now){
  const dt = now - lastTS; lastTS = now;
  for (let i=0;i<3;i++){
    const cyl = cylEls[i]; if (!cyl) continue;
    if (spinning[i]) rotX[i] = (rotX[i] + ROT_SPEEDS[i] * dt) % 360;
    cyl.style.transform = `rotateX(${rotX[i]}deg)`;
  }
  requestAnimationFrame(tick);
}
function currentSymbol(i){
  const list = reels[i];
  const n = list.length;
  const step = 360 / n;
  const idx = Math.round((-rotX[i]) / step) % n;
  const wrapped = (idx + n) % n;
  return list[wrapped];
}
function stopReel(i){
  if (!spinning[i]||!ws||ws.readyState!==1) return;
  spinning[i]=false;
  const symbol = currentSymbol(i);
  ws.send(JSON.stringify({type:"stop_reel", reel:i, symbol}));
  setStatus(`Locked ${"ABC"[i]}: ${symbol}.`);
  // If all three are stopped locally, disable stop buttons until reset
  if (spinning.every(v=>!v)) {
    document.querySelectorAll('button:not(.primary)').forEach(b=>b.disabled=true);
  }
}
function onReelStopped(i,symbol){  // Deze komt wordt niet gebruikt na reset
  // Ensure the spinning flag is cleared when a reel is stopped. Without this the
  // animation will continue if the stop was triggered from a physical button,
  // because spinning[i] would remain true. This prevents the cylinder from
  // being overwritten by the tick loop after snapping to the target symbol.
  spinning[i] = false;
  badgeEls[i].textContent = `Stopped: ${symbol}`;
  badgeEls[i].style.display='block';
  const list = reels[i]; const idx = list.indexOf(symbol); if (idx<0) return;
  const step = 360 / list.length;
  rotX[i] = -idx * step;
  cylEls[i].style.transform = `rotateX(${rotX[i]}deg)`;

  // If all reels have stopped locally, disable the stop buttons until reset. This
  // mirrors the logic in stopReel() so that hardware presses also lock the UI.
  if (spinning.every(v=>!v)) {
    document.querySelectorAll('button:not(.primary)').forEach(b=>b.disabled=true);
  }

  // Attempt to trigger generation if the server has indicated all reels are stopped
  // and this was the last snap to complete via the handshake mechanism.
  maybeShowOverlay();
}
function resetAll(){
  badgeEls.forEach(b=>{ b.classList.remove('show'); b.style.display='none'; b.textContent='Stopped';});
  spinning=[true,true,true];
  setStatus("Ready. Stop each reel with your chosen symbol.");
  hideOverlay();
  document.querySelectorAll('button:not(.primary)').forEach(b=>b.disabled=false);
  if(ws&&ws.readyState===1) ws.send(JSON.stringify({type:"reset"}));
}
connect();
</script>

<script>
// === POLISH PACK JS v1 ===
(function(){
  const FLAVOR = ["Nice pick!", "Two to go!", "Feeling lucky?", "Lock it in!", "Almost there!"];
  const oldSetStatus = window.setStatus;
  window.setStatus = function(msg){
    try {
      if (msg && msg.startsWith("Locked")) {
        msg += " " + FLAVOR[Math.floor(Math.random()*FLAVOR.length)];
      }
    } catch(e){}
    return oldSetStatus(msg);
  }

  const origOnReelStopped = window.onReelStopped;
  window.onReelStopped = function(i, symbol){
    origOnReelStopped(i, symbol);
    const b = document.getElementById("sb"+i);
    if (b) b.classList.add("show");

    try {
      const cyl = window.cylEls?.[i];
      const list = window.reels?.[i] || [];
      const idx = list.indexOf(symbol);
      if (!cyl || idx<0) return;
      const step = 360 / list.length;
      const current = window.rotX?.[i] || 0;
      const target = -idx * step;
      const overshoot = 8;
      const frames = 18;
      let f = 0;
      function easeOutCubic(t){ return 1 - Math.pow(1-t,3); }
      (function anim(){
        f++;
        const t = Math.min(f/frames, 1);
        const e = easeOutCubic(t);
        const val = current + (target - current + (t<1 ? overshoot : 0)) * e;
        window.rotX[i] = val;
        cyl.style.transform = `rotateX(${val}deg)`;
        if (f < frames) requestAnimationFrame(anim);
        else {
          window.rotX[i] = target;
          cyl.style.transform = `rotateX(${target}deg)`;
          // After the overshoot animation completes, attempt to show the overlay
          // if the server has indicated that all reels are stopped. This waits
          // until the final reel's badge and snap have painted before
          // revealing the loading overlay.
          try { if (typeof window.maybeShowOverlay === 'function') window.maybeShowOverlay(); } catch(e){}
        }
      })();
    } catch(e){}
  }

  window.pullLever = function(){
    const btn = document.querySelector(".lever");
    if (btn){ btn.style.transform = "translateY(2px)"; setTimeout(()=>btn.style.transform="",120); }
    if (typeof window.resetAll === "function") window.resetAll();
  }

  window.addEventListener("keydown", (e)=>{
    const k = e.key.toLowerCase();
    if (k === "r") { e.preventDefault(); window.pullLever(); }
    if (k === "a") { e.preventDefault(); window.stopReel?.(0); }
    if (k === "s") { e.preventDefault(); window.stopReel?.(1); }
    if (k === "d") { e.preventDefault(); window.stopReel?.(2); }
  });
})();
// === END POLISH PACK JS v1 ===
</script>
</body>
</html>
