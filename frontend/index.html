<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<meta content="width=device-width,initial-scale=1" name="viewport"/>
<title>Brainrot Slot Machine</title>
<!-- <link rel="stylesheet" href="https://use.typekit.net/ihx7ouu.css"> -->
<link rel="stylesheet" href="/static/styles/common.css">
<link rel="stylesheet" href="/static/styles/slot.css">
</head>
<body>
<header>
  <div class="status" id="status">Stop each reel with the symbol you want on the payline.</div>
</header>

<!-- SLOT UI -->
<div class="wrap">
  <div class="reel"><div class="scene"><div class="cyl" id="cyl0"></div></div><div class="fadeMask"></div><div class="stopBadge" id="sb0">Stopped</div></div>
  <div class="reel"><div class="scene"><div class="cyl" id="cyl1"></div></div><div class="fadeMask"></div><div class="stopBadge" id="sb1">Stopped</div></div>
  <div class="reel"><div class="scene"><div class="cyl" id="cyl2"></div></div><div class="fadeMask"></div><div class="stopBadge" id="sb2">Stopped</div></div>
</div>

<footer class="controls">
  <button onclick="stopReel(0)">Stop A</button>
  <button onclick="stopReel(1)">Stop B</button>
  <button onclick="stopReel(2)">Stop C</button>
  <button class="primary" id="resetBtn" onclick="resetAll()">Reset</button>
  <button class="primary" onclick="window.location.href='/gallery.html'">ðŸ“¸ View Gallery</button>
</footer>

<!-- LOADING OVERLAY -->
<div id="loadingOverlay" class="loading-overlay" aria-hidden="true">
  <div class="loading-card" role="dialog" aria-live="polite">
    <div class="spinner" aria-hidden="true"></div>
    <div class="loading-title" id="loadingTitle">Workingâ€¦</div>
    <div class="loading-sub" id="loadingSub">Composing prompt & generating your brainrot.</div>
    <div class="progressbar"><div></div></div>
    <div class="hint">This might take a moment...</div>
  </div>
</div>

<script>
const ROW_H = 92;
const ROT_SPEEDS = [0.025, 0.025, 0.025]; // deg/ms
let ws;
let reels = [[],[],[]];
let spinning = [true,true,true];
let rotX = [0,0,0];
let lastTS = performance.now();
let cylEls = [];
let badgeEls = [];
let generationInProgress = false;
// Track when the server has declared that all reels are stopped. We defer
// showing the loading overlay until the final reel's animation and badge
// have painted on screen.
let allStoppedPending = false;
// Helper to trigger generation after all reels stop
function maybeShowOverlay(){
  if (allStoppedPending && spinning.every(v => !v)){
    if (ws && ws.readyState === 1) {
      ws.send(JSON.stringify({type: "start_generation"}));
      allStoppedPending = false;
    }
  }
}
// Loading overlay helpers
function showOverlay(title="Brewing your brainrotâ€¦", sub="Composing prompt & generating image.") {
  const o = document.getElementById('loadingOverlay');
  document.getElementById('loadingTitle').textContent = title;
  document.getElementById('loadingSub').textContent = sub;
  o.classList.add('show');
  o.setAttribute('aria-hidden', 'false');
}

function hideOverlay(){
  const o = document.getElementById('loadingOverlay');
  o.classList.remove('show');
  o.setAttribute('aria-hidden', 'true');
}

function connect(){
  ws = new WebSocket(`ws://${location.host}/ws`);
  
  ws.onmessage = (ev)=>{
    const msg = JSON.parse(ev.data);

    console.log(msg);

    if (msg.type === 'init') initUI(msg.reels);
    // A physical switch state change from the server; capture the visible symbol and send
    // a stop_reel command on state change. This ensures that the spinning
    // state and UI are updated consistently when using GPIO switches.
    if (msg.type === 'gpio_press') {
      // Handle both press and release events - any state change stops the reel
      if (spinning[msg.reel] && ws && ws.readyState === 1) {
        spinning[msg.reel] = false;
        const symbol = currentSymbol(msg.reel);
        ws.send(JSON.stringify({ type: "stop_reel", reel: msg.reel, symbol }));
        const action = msg.action || 'activated';
        setStatus(`Locked ${"ABC"[msg.reel]} (GPIO ${action}): ${symbol}.`);
        if (spinning.every(v => !v)) {
          document.querySelectorAll('button:not(.primary)')
            .forEach(b => b.disabled = true);
        }
      }
    }

    if (msg.type === 'reel_stopped') 
        onReelStopped(msg.reel, msg.symbol);

    if (msg.type === 'all_stopped') {
      // Set status and flag that backend is ready
      allStoppedPending = true;
      setStatus("All reels stopped. Ready to generateâ€¦");
      // Check immediately if frontend is also ready (all animations done)
      maybeShowOverlay();
      return;
    }

    if (msg.type === 'generation_started') {
      generationInProgress = true;
      setResetDisabled(true);
      setStatus("Generating your brainrotâ€¦");
      showOverlay("Brewing your brainrotâ€¦","Composing prompt & generating image.");
    }

    if (msg.type === 'image_ready') {
      generationInProgress = false;
      setResetDisabled(false);
      hideOverlay();
      window.location.href = "/gallery.html?url=" + encodeURIComponent(msg.url)
                           + "&name=" + encodeURIComponent(msg.italian_name)
                           + "&prompt=" + encodeURIComponent(msg.prompt);
    }

    if (msg.type === 'error') {
      generationInProgress = false;
      setResetDisabled(false);
      hideOverlay();
      setStatus("âš ï¸ " + msg.message + " Click Reset to try again.");
      // Auto-enable reset button on error
      document.querySelectorAll('button').forEach(b => b.disabled = false);
    }

    if (msg.type === 'reset_ok') {
      generationInProgress = false;
      setResetDisabled(false);
    }

  };

  ws.onclose = ()=>{
    setStatus("Disconnected. Reconnectingâ€¦");
    hideOverlay();
    generationInProgress = false;
    setResetDisabled(false);
    setTimeout(connect, 800);
  };

}

function setStatus(s){
    document.getElementById('status').textContent = s; 
}

function setResetDisabled(disabled){
  const btn = document.getElementById('resetBtn');
  if (btn) btn.disabled = !!disabled;
}

function buildCylinder(i){
  const cyl = document.getElementById(`cyl${i}`);
  cyl.innerHTML = "";
  const items = reels[i]; const n = items.length; const step = 360 / n; const R = (ROW_H * n) / (2 * Math.PI);
  items.forEach((txt, idx)=>{
    const panel = document.createElement('div');
    panel.className = 'panel'; panel.textContent = txt;
    panel.style.transform = `rotateX(${idx * step}deg) translateZ(${R}px)`;
    cyl.appendChild(panel);
  });
  cyl.dataset.step = step.toString();
  rotX[i] = 0; cyl.style.transform = `rotateX(${rotX[i]}deg)`;
}

function initUI(reelData){
  reels = [reelData[0], reelData[1], reelData[2]];
  cylEls = [document.getElementById('cyl0'), document.getElementById('cyl1'), document.getElementById('cyl2')];
  badgeEls = [document.getElementById('sb0'), document.getElementById('sb1'), document.getElementById('sb2')];
  for (let i=0;i<3;i++) buildCylinder(i);
  lastTS = performance.now(); requestAnimationFrame(tick);
}

function tick(now){
  const dt = now - lastTS; lastTS = now;
  for (let i=0;i<3;i++){
    const cyl = cylEls[i]; if (!cyl) continue;
    if (spinning[i]) rotX[i] = (rotX[i] + ROT_SPEEDS[i] * dt) % 360;
    cyl.style.transform = `rotateX(${rotX[i]}deg)`;
  }
  requestAnimationFrame(tick);
}

function currentSymbol(i){
  const list = reels[i];
  const n = list.length;
  const step = 360 / n;
  const idx = Math.round((-rotX[i]) / step) % n;
  const wrapped = (idx + n) % n;
  return list[wrapped];
}
function stopReel(i){
  if (!spinning[i]||!ws||ws.readyState!==1) return;
  spinning[i]=false;
  const symbol = currentSymbol(i);
  ws.send(JSON.stringify({type:"stop_reel", reel:i, symbol}));
  setStatus(`Locked ${"ABC"[i]}: ${symbol}.`);
  // If all three are stopped locally, disable stop buttons until reset
  if (spinning.every(v=>!v)) {
    document.querySelectorAll('button:not(.primary)').forEach(b=>b.disabled=true);
  }
}
function onReelStopped(i,symbol){
  spinning[i] = false;
  badgeEls[i].textContent = `Stopped: ${symbol}`;
  badgeEls[i].style.display='block';
  const list = reels[i]; const idx = list.indexOf(symbol); if (idx<0) return;
  const step = 360 / list.length;
  rotX[i] = -idx * step;
  cylEls[i].style.transform = `rotateX(${rotX[i]}deg)`;

  if (spinning.every(v=>!v)) {
    document.querySelectorAll('button:not(.primary)').forEach(b=>b.disabled=true);
  }

  maybeShowOverlay();
}
function resetAll(){
  if (generationInProgress) {
    setStatus("Generation in progress. Please waitâ€¦");
    return;
  }
  badgeEls.forEach(b=>{ b.classList.remove('show'); b.style.display='none'; b.textContent='Stopped';});
  spinning=[true,true,true];
  setStatus("Ready. Stop each reel with your chosen symbol.");
  hideOverlay();
  document.querySelectorAll('button:not(.primary)').forEach(b=>b.disabled=false);
  setResetDisabled(false);
  generationInProgress = false;
  if(ws&&ws.readyState===1) ws.send(JSON.stringify({type:"reset"}));
}
connect();
</script>

<script>
// === POLISH PACK JS v1 ===
(function(){
  const FLAVOR = ["Nice pick!", "Two to go!", "Feeling lucky?", "Lock it in!", "Almost there!"];
  const oldSetStatus = window.setStatus;
  window.setStatus = function(msg){
    try {
      if (msg && msg.startsWith("Locked")) {
        msg += " " + FLAVOR[Math.floor(Math.random()*FLAVOR.length)];
      }
    } catch(e){}
    return oldSetStatus(msg);
  }

  const origOnReelStopped = window.onReelStopped;
  window.onReelStopped = function(i, symbol){
    origOnReelStopped(i, symbol);
    const b = document.getElementById("sb"+i);
    if (b) b.classList.add("show");

    try {
      const cyl = window.cylEls?.[i];
      const list = window.reels?.[i] || [];
      const idx = list.indexOf(symbol);
      if (!cyl || idx<0) return;
      const step = 360 / list.length;
      const current = window.rotX?.[i] || 0;
      const target = -idx * step;
      const overshoot = 8;
      const frames = 18;
      let f = 0;
      function easeOutCubic(t){ return 1 - Math.pow(1-t,3); }
      (function anim(){
        f++;
        const t = Math.min(f/frames, 1);
        const e = easeOutCubic(t);
        const val = current + (target - current + (t<1 ? overshoot : 0)) * e;
        window.rotX[i] = val;
        cyl.style.transform = `rotateX(${val}deg)`;
        if (f < frames) requestAnimationFrame(anim);
        else {
          window.rotX[i] = target;
          cyl.style.transform = `rotateX(${target}deg)`;
          try { if (typeof window.maybeShowOverlay === 'function') window.maybeShowOverlay(); } catch(e){}
        }
      })();
    } catch(e){}
  }

  // Keyboard shortcuts
  window.addEventListener("keydown", (e)=>{
    const k = e.key.toLowerCase();
    if (k === "r") { e.preventDefault(); if (typeof window.resetAll === "function") window.resetAll(); }
    if (k === "a") { e.preventDefault(); window.stopReel?.(0); }
    if (k === "s") { e.preventDefault(); window.stopReel?.(1); }
    if (k === "d") { e.preventDefault(); window.stopReel?.(2); }
  });
})();
</script>
</body>
</html>
